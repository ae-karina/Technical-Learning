<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script type="text/javascript">
    // 初始化参数  默认值:undefined
    /* function test(a, b) {
      console.kog(a);
      console.kog(b);
    }
    test(1);  1/undefined */

    // 不传参也想有默认值，则直接赋值
    /* function test(a = 1, b) {
      console.kog(a);
      console.kog(b);
    }
    test();   1 / undefined */

    //想让a保留原来的默认值，b传入实参
    /*  function test(a = 1, b) {
       console.kog(a);
       console.kog(b);
     }
     test(undefined,2);  1 / 2 */

    //等于
    /*  function test(a = undefined, b) {
     console.kog(a);
     console.kog(b);
     }
     test(1,2); 1 / 2 */

    /*  a   undefined
     arguments[0]   1  
                      实参和形参之间选择哪一个的值：谁不是undefined就选谁
     test(undefined,2); */

    //es6的写法，形参赋值低版本的浏览器不支持  es5不能
    /* function test(a = 1, b = 2) {
    console.kog(a);
    console.kog(b);
    }
    test(); 1 / undefined */

    //es5 给函数参数赋值写法  企业里一般这样写
    /* function test(a, b) {
      var a = arguments[0] || 1;
      var b = arguments[1] || 2;
      console.log(a + b);
    }
    test();3
    test(3,4);7 */


    //另一种写法
    /* function test(a, b) {
      var a, b;
      if (typeof (arguments[0]) !== 'undefined') {
        a = arguments[0];
      } else {
        a = 1;
      }
      if (typeof (arguments[1]) !== 'undefined') {
        b = arguments[1];
      } else {
        b = 1;
      }
      console.log(a + b);
    }
    test(3, 4); // 7

    不建议使用 var a = a || 1  这样的写法 */

    //三元运算写法，一般来说这个更好
    /* function test(a, b) {
      var a = typeof (arguments[0] !== 'undefined' ? arguments[0] : 1)
      var b = typeof (arguments[1] !== 'undefined' ? arguments[1] : 1)

      console.log(a + b);
    }
    test(); //3 */







    // n 的阶乘 - 不能for循环  递归
    // fact(n);
    // n != n * (n - 1); 规律
    //出口  否则会一直循环

    /* function fact(n) {
      //通过出口找到最下面的值，然后再依次往上运算
      if (n === 1) {
        return 1;
      }
      return n * fact(n - 1); //结果出来了才会return出去
    }

    console.log(fact(5)); //120 */

    /* 执行过程

    n = 5;
    fact(5) = 5 * fact(4);
    fact(4) = 4 * fact(3);
    fact(3) = 3 * fact(2);
    fact(2) = 2 * fact(1);

    这时n = 1， 变为
    fact(5) = 5 * fact(4);
    fact(4) = 4 * fact(3);
    fact(3) = 3 * fact(2);
    fact(2) = 2 * 1;

    fact(5) = 5 * fact(4);
    fact(4) = 4 * fact(3);
    fact(3) = 3 * 2;
    fact(2) = 2 * 1;

    fact(5) = 5 * fact(4);
    fact(4) = 4 * 6;
    fact(3) = 3 * 2;
    fact(2) = 2 * 1;

    fact(5) = 5 * 24; //最终结果为120
    fact(4) = 4 * 6;
    fact(3) = 3 * 2;
    fact(2) = 2 * 1; */

    // 1. n3=n2+n1;
    // 2. n<=0 n<=2  1,2位是1
    /*   function fb(n) {
        if (n <= 0) {
          return 0;
        }
        if (n <= 2) {
          return 1;
        }
        return fb(n - 1) + fb(n - 2);
      }

      console.log(fb(5)); //5

      执行过程

      fb(5) = fb(4) + fb(3);
      fb(4) = fb(3) + fb(2);
      fb(3) = fb(2) + fb(1);

      fb(5) = fb(4) + fb(3);
      fb(4) = fb(3) + fb(2);
      fb(3) = 1 + 1;

      fb(5) = fb(4) + fb(3);
      fb(4) = 2 + 1;
      fb(3) = 1 + 1;

      fb(5) = 3 + 2; //5
      fb(4) = 2 + 1;
      fb(3) = 1 + 1; */
    // 递归总是在走到出口的时候，在一步步返回向上计算，返回结果
    /* 找到规律
    找到出口 */






    //预编译
    /* console.log(a); //报错
    console.log(a); // 都只报错，后面的不执行
    console.log(a); */

    //1.检查通篇的语法错误
    //1.5.预编译的过程
    //2.解释一行，执行一行

    /* test(); //放在上面也能执行
    function test() {
      console.log(1);
    } */

    /*  console.log(a); // undefined
     var a = 10; */

    /*  console.log(a); // undefined
     var a; */

    /*  console.log(a); // 报错
     //声明重要，赋值不重要，和声明的位置也没关系 */

    // 函数声明整体提升，变量只有声明提升，赋值是不提升

    // var a = 1; //2个步骤  声明a变量，并赋值

    /*  console.log(a); //打印出函数

     function a(a) {
       var a = 10;
       var a = functon() {

       }
     }
     var a = 1; */



    // 暗示全局变量  imply global varibal

    // a = 1; //1  和var a = 1 的结果一样，
    // console.log(a);

    // var a = 1; //1 和var a = 1 的结果一样，
    // b = 2; // 未被声明就被赋值，暗示就是全局变量，都归window
    // console.log(window.b);
    // window 本身就是全局的作用域， 全局域， 全局变量都归全局域所有

    // 单独访问window里面的属性或者以对象的形式访问window的对象(window.a) 也可以


    // 不管你var了还是没var，都是存在window里面的
    // window = {
    //   a: 1,
    //   b: 2
    // }

    /* function test(a) {
      var a = b = 1; //先把1赋值给吧，b再赋值给a
    }
    test();
    console.log(window.b); //1  函数内部没有声明变量的话，直接存到window里面
    console.log(window.a); //undefined  访问对象里面不存在的属性就是undefined
    console.log(a); //报错     访问变量，而变量没定义  两种不同访问方式，仅仅是结果不同而已 */


    // 函数预编译，函数执行之前要进行的一个步骤
    /* function test(a) {
      console.log(a);
      var a = 1;
      console.log(a);

      function a() {}
      console.log(a);
      var b = function () {}
      console.log(b);

      function d() {}
    }
    test(2); */
    /* function a() {}
    1
    1
    function () {} */

    // AO activation object 活跃对象，函数上下文   函数执行之前要进行的一个步骤

    // 函数上下文
    // AO={  先创建对象
    // 1.寻找函数的形参和变量声明（变量声明的提升）  放到AO里面去
    // 2.把实参的参数值赋值给形参
    // 3.寻找函数，函数体的函数声明，然后赋值函数体
    // 4.执行函数
    // a:undefined ->
    //           2 -> 
    //           function a() {} ->
    //           1,
    // b:undefined -> function () {}
    // d:function d() {}
    // }


    /*  function test(a, b) {
       console.log(a);
       c = 0;
       var c;
       a = 5;
       c = 6;
       console.log(b);

       function b() {}

       function d() {}
       console.log(b);
     }
     test(1); //1 6 6  预编译的时候已经做过函数了，执行的时候不会再做一次 */

    // 预编译做剩下的事情由函数执行去做

    // AO = {
    // a:undefined ->
    //             1 ->
    //             5,
    // b:undefined -> function b() {} ->
    //                              6,
    // c:undefined ->0,
    // d:undefined -> function d() {}
    // }



    /* var a = 1;

    function a() {
      console.log(2);
    }

    console.log(a); //1 */

    // 整个通篇js执行之前产生了  GO global object  和AO一起交执行机上下文
    // GO{
    // 1.寻找变量声明（因为没有参数，少了参数的哪些步骤）
    // 2.寻找函数声明
    // 3.执行
    // a: undefined -> function a(){}  -> 1;
    // }
    // GO === window  window存储全局变量的过程也一样  要考虑执行顺序的问题

    /* console.log(a, b);

    function a() {}
    var b = function () {}
    // GO={
    // b:undefined,
    // a:undefined -> function a() {}   函数声明提升了
    // }



    console.log(a); //  打印函数
    var a = 1;
    function a() {
      console.log(2);
    } */

    /* function test() {
      var a = b = 1;
      console.log(a);
    }
    test(); //1
    // GO{
    //    b: 1
    // }

    // AO{    自己有的找自己的，自己没有的到GO里面找
    //   a: undefined  没有实参，函数声明，到这之后直接开始执行
    //            -> 1 这里没有吧，往上（GO）里面找，找到之后赋值
    // }

    var b = 1;

    function test() {
      var a = 1;
      var b = 2;
      console.log(b);
    }
    test(); //2 */


    /*  var b = 3;
     console.log(a);

     function a(a) {
       console.log(a);
       var a = 2;
       console.log(a);

       function a() {}
       var b = 5;
       car.console.log(b);
     }
     a(1); */

    // GO{
    // b:undefined ->3,
    // a:function a() {...}
    // }


    // AO{
    // a:undefined
    // 1
    // function a(){}
    // 2,
    // b:undefined ->5,
    // }

    // 结果
    /* function a(a) {
    console.log(a);
    var a = 2;
    console.log(a);
    function a() {}
    var b = 5;
    car.console.log(b);
    }

    f a(){}
    2
    5 */




    /*  a = 1;

     function test() {
       console.log(a);
       a = 2;
       console.log(a);
       var a = 3;
       console.log(a);
     }

     test();
     var a;
     // GO{
     // a:undefined
     //          1,  执行
     // test:function test(){...}
     // 
     // AO={
     // a:undefined,   因为AO自己有a，不需要到GO里面找，所以打印不出1
     // 2,
     // 3
     // } */


    function test() {
      console.log(b);
      if (a) {
        var b = 2;
      }

      c = 3;
      console.log(c);
    }

    var a;
    test();
    a = 1;
    console.log(a);

    // GO{
    // a:undefined->
    // undefined->
    // 1
    // test:function test(){}
    // c:3
    // }
    // AO{
    //  b:undefined-> // 预编译的时候，不会看判断条件
    // undefined
    // 
    // }



    // function test() {
    //   return a; //终止了
    //   a = 1;

    //   function a() {}
    //   var a = 2;
    // }

    // console.log(test());


    // AO {
    //   a: undefined - > function a() {}     f a(){}
    // }


    /*   function test() {
      a = 1;

      function a() {}
      var a = 2;
      return a;
    }
    console.log(test());

    AO {
      a: undefined      - >
        function a() {} - >
                     1  - >
                     2,          //2
    }
 */


    /*  a = 1;

     function test(e) {
       function e() {}
       arguments[0] = 2;
       console.log(e);
       if (a) {
         var b = 3;
       }
       var c;
       a = 4;
       var a; //声明了，所以在AO里面
       console.log(b);
       f = 5;
       console.log(c);
       console.log(a);
     }

     var a;
     test(1);
     console.log(a);
     console.log(f);
     // GO={
     // a:undefined ->1
     // test:function test(){...}
     // f:5
     // }

     // AO={
     //   e:undefined->
     //             1->
     //   function e() {}->
     //             2,
     //   b:undefined,
     //   c:undefined,
     //   a:undefined ->4
     // }


     结果
     2
     undefined
     undefined
     4
     1
     5 */


    var a = false + 1; //1  隐式转换
    console.log(a);

    var b = false == 1; //false
    console.log(b);


    //   'undefinde'          -1         NaN
    if (typeof (a) && (-true) + (+undefined) + '') {
      console.log('通过了');
    } else {
      console.log('没通过');
    }

    console.log(a); //通过了

    if (1 + 5 * '3' === 16) { //隐式转换
      console.log('通过了');
    } else {
      console.log('未通过');
    } //通过了


    //            空格1  0       0           
    console.log(!!' ' + !!'' - !!false || '未通过了'); //1

    window.a || (window.a = '1'); //1  括号的运算最高，再走或运算
    console.log(window.a);
  </script>
</body>

</html>