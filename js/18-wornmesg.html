<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script type="text/javascript">
    // JS错误信息类型 面试有时会问
    // 1、 SyntaxError  语法错误

    // 变量名不规范
    // var 1 = 1; //Uncaught SyntaxError: Unexpected number  系统自动抛出的语法错误  错误是一个意外的数字
    // var 1ab = 1; Invalid or Unexpected token  无效的意外的标记

    // 关键字不可赋值
    // new = 5; //Unexpected token
    // function = 1; //Unexpected token

    // 基本的语法错误
    // var a = 5: //Unexpected token ':'
    // function 1Test() {}//Invalid or Unexpected token



    // 2、ReferenceError  引用错误
    // 变量或函数未被声明
    // test(); //Uncaught ReferenceError: test is not defined
    // console.log(a); //Uncaught ReferenceError: a is not defined

    // 给无法被赋值的对象赋值的时候
    // var a = 1 = 2; //Uncaught ReferenceError: Invalid left-hand side in assignment
    /*  var a = 1; //异常赋值
     console.log(a) = 1; //Uncaught ReferenceError: Invalid left-hand side in assignment */

    //  3、RangeError范围错误
    // 数组长度赋值为负数
    /* var arr = [1, 2, 3]; //自动在后面加3逗号，两个空项
    arr.length = 5;
    console.log(arr); //[1, 2, 3, empty × 2]

    var arr = [1, 2, 3];
    arr.length = -1;
    console.log(arr); //Uncaught RangeError: Invalid array length */

    // 对象方法参数超出可行范围
    /* var num = new Number(66.66);
    console.log(num.toFixed(1)); //留小数点几位 66.7

    var num = new Number(66.66);
    console.log(num.toFixed(-
    1)); //18-wornmesg.html:55 Uncaught RangeError: toFixed() digits argument must be between 0 and 100 at Number.toFixed( < anonymous > ) */


    //4、 TypeError 类型错误
    // 调用不存在的方法
    // test(); //Uncaught ReferenceError: test is not defined
    // 123(); //认为123定义没定义 认为不是function 先判断类型 是不是function function才能跟括号 不是则不能 Uncaught TypeError: 123 is not a function

    /* var obj = {};
    obj.say(); //Uncaught TypeError: obj.say is not a function   在对象里找不到这个方法  认为属于属性  看到又有括号就告诉你这不是一个function
    obj.say; //不报错
    // 证明JS没有这个方法认为你是一个属性 只是没有赋值 但是后面属性执行了就是类型错误 因为属性不可能被执行 看到又有括号就告诉你这不是一个function */

    // 实例化原始值
    // var a = new 'string'; //Uncaught TypeError: "string" is not a constructor  new后面一定要跟函数  构造函数/普通函数  
    // var a = new 123; //Uncaught TypeError: 123 is not a constructor 实例化的必须是构造函数



    // 5、URIError   URI错误
    // URI:UNIFORM RESOURCE IDENTIFIER
    //      统一资源标识符
    // URL:UNIFORM RESOURCE LOCATOR
    //      统一资源定位符
    // URN:UNIFORM RESOURCE NAME
    //      统一资源名称

    // URL:http://www.baidu.com/news#today  //后面的是资源空间
    //     ftp://www.baidu.com/ftp#developer  
    // URN:www.baidu.com/ftp#developer   ->ID  指代了资源的唯一性  唯一的资源访问
    // href="tel:13900000000"  URN  不指代特定的可访问的资源  tel：途径/方法
    // href="mailto:523579987@qq.coms" URN 指代资源的名称  无法访问特定的资源/程序   不是自己执行通过该地址访问   而是程序自执行去调用

    /*  var myUrl = 'http://www.baidu.cin?name=艾小野';
     var newUrl = encodeURI(myUrl); //encodeURI 把URL地址里的中文变成中文字符编码
     console.log(newUrl); //http://www.baidu.cin?name=%E8%89%BE%E5%B0%8F%E9%87%8E

     var myUrl = '艾小野';
     var newUrl = encodeURI(myUrl); //encodeURI 把URL地址里的中文变成中文字符编码
     console.log(newUrl); //%E8%89%BE%E5%B0%8F%E9%87%8E
     // URI写什么都可以 资源标识 不能判断是否真的有资源 所以可以用encodeURI转为中文编码字符


     var myUrl = 'http://www.baidu.cin?name=艾小野';
     var newUrl = encodeURI(myUrl); //encodeURI 把URL地址里的中文变成中文字符编码
     console.log(newUrl); //http://www.baiddeu.cin?name=%E8%89%BE%E5%B0%8F%E9%87%8E
     var newNewUrl = decodeURI(myUrl); //decodeURI 中文字符编码变成中文
     console.log(newNewUrl); //http://www.baidu.cin?name=艾小野
     // encodeURI decodeURI JS内置的方法

     var str = decodeURI('%fdsdf%'); //Uncaught URIError: URI malformed at decodeURI( < anonymous > )  不符合常规的URI无法解析  这个URI是乱写的  这个错误基本在这两个上面 */



    //  6、EvalError eval函数执行错误  现在不怎么报错 以前是 这个函数不推荐使用
    // eval('var a = 1; console.log(a)'); //1  程序写成字符串  放在eval里面就可以执行
    // var str = eval('1');
    // console.log(str); //1

    /* var obj = {
      a: 1,
      b: 2
    }
    console.log(eval('obj')); //{a: 1, b: 2}
    console.log(eval(obj)); //{a: 1, b: 2} */
    // 不规范 应该是字符串才能执行  但是不是字符串也可以  所以不推荐使用

    /* var obj = {
      'a': 1, //对象的属性可以写成字符串形式  这种形式就是JSON 这种情况下和对象一样 只是JSON 一般用双引号  和后端的转义有关  后端传过来的字符串一般用双引号  所以一般用双引号
      'b': 2
    }
    obj['a'] obj.b obj.a */
    // JS中JSON也是对象  这样的形式其实就是一个JSON对象 不是字符串   变成字符串才是字符串
    // var obj = {
    //   "a": 1,
    //   "b": 2
    // }

    // 这个就不是JSON字符串/对象了 是普通对象  因为JSON 字符串/对象里面不可以嵌有方法
    /* var obj = {
      "a": 1,
      "b": 2,
      "say": function () {}
    } */
    // JSON是存储数据用的  

    // JSON字符串  后端传过来的数据一般也是这样
    /*  var jsonData = '[' +
       '{' +
       '"name" : "abc"' +
       '},' +
       '{' +
       '"name" : "bcd"' +
       '},' +
       '{' +
       '"name" : "efg"' +
       '}' +
       ']';

     console.log(jsonData); //[{"name" : "abc"},{"name" : "bcd"},{"name" : "efg"}]
     var data = eval('(' + jsonData + ')'); //eval很快可以把字符串数据变成可循环的JSON对象
     console.log(data);
     // 0:{name: 'abc'}
     // 1:{name: 'bcd'}
     // 2:{name: 'efg'}

     for (var i in data) {
       var item = data[i];
       console.log(item.name);
     } */
    // abc
    // bcd
    // efg

    // 最大的用处 后台后端与前端数据对接  JSON数据  后端获取JSON数据
    // var jsonStr =

    // 不推荐使用的原因
    // 语法不规范
    // 不好调试
    // 性能问题 不理想
    // json.psrse可也实现 
    // 压缩代码会出错
    // 安全性问题  引起XSS的攻击  不是eval本身问题 可能是写的代码问题   eval input 两标签合用的时候
    // 可读性太差

    // es6完全抛弃

    // 六种错误可以完全人为抛出
    // 自定义错误
    /* var error = new SyntaxError('代码错误了');
    console.log(error); //SyntaxError: 代码错误了

    var error = new ReferenceError('代码错误了');
    console.log(error); //ReferenceError: 代码错误了

    var error = new TypeError('代码错误了');
    console.log(error); //TypeError: 代码错误了

    // 错误类型？
    // 有六种，有1、2、3、....每种类型都对应了一个相应的构造函数，这个构造函数都可以通过实例化错误对象，然后可以输出相应的错误，我可以自定义错误

    var error = new Error(); //还有这个 */

    // 系统自动为我们抛出错误
    // console.log('正常执行1');
    // console.log(a);
    // console.log('正常执行2');
    // // 报错后面的就不执行了  有无方法保护一下错误
    /* 
        try {
          console.log('正常执行1');
          console.log(a);
          console.log('正常执行2'); //不抛出错误 但是还是出错后面的没执行
        } catch (e) {
          console.log(e); //ReferenceError: a is not defined 是一个字符串
          console.log(e.name + ':' + e.message); //ReferenceError:a is not defined
          // 错了走这里 多了一种备用方案
        }

        try {
          console.log('正常执行1');
          console.log('1');
          console.log('正常执行2');
        } catch (e) { //捕获try的错误
          console.log(e); //正常的时候不走里面
        }

        try {
          console.log('正常执行1');
          console.log(a); //执行报错
          console.log(b); //不执行
        } catch (e) {
          console.log(e.name + ':' + e.message);
        } finally { //不管有无错误 finally都会执行
          console.log('正常执行3');
        }
        console.log('正常执行4'); */

    // 正常执行1
    // ReferenceError: a is not defined
    // 正常执行3
    // 正常执行4
    // 多了一种处理程序的可能新性  try的内容可能与finally不太相关  把可能出错的放在try，一定要执行的放在finally 分开可能错误和一定要执行 不影响下面函数的执行  这时候finally 和放在外面的函数没有什么区别  只是看起来较为工整  有序列化的感觉  写在外边序列化感觉就浅一些

    // JSON字符串  等着后端传过来  判断传没传成功
    /* var jsonStr = '';
    try {
      console.log('我要执行啦！！！！！');
      var json = JSON.parse(jsonStr); //JSON.parse里面不能是空串  会报错
      console.log(json);
    } catch (e) {
      var errorTip = { //API接入 提示信息集合  告诉你错误代码是什么  怎么样调试  提示错误编号和名称  这样的信息一般是从后端传回来
        name: '数据传输失败',
        errorCode: '10010'
      }
      console.log(errorTip);
    }
 */
    // {name: '数据传输失败', errorCode: '10010'}
    // errorCode:"10010"
    // name:"数据传输失败"
    // 换方案执行  不报错  获取错误以后  换一个方案执行


    /* var jsonStr = '';
    try {
      if (jsonStr == '') {
        throw 'JSON字符串为空'; //throw抛出错误信息  自定义信息
      }
      console.log('我要执行啦！！！！！');
      var json = JSON.parse(jsonStr);
      console.log(json);
    } catch (e) {
      console.log(e); //JSON字符串为空
      var errorTip = {
        name: '数据传输失败',
        errorCode: '10010'
      }
      console.log(errorTip);
    } */

    // try catch  用在大型的程序插件比较多  让程序开发者知道是什么  一般程序开发用得不多 



    // ES5严格模式  为ES6做铺垫

    // ECMAScript  DOM BOM    JavaScript语法规范  方法规范
    // 97   1.0
    // 98   2.0
    // 99   3.0
    // es5对3.0没做很大的修改
    // 07   4.0  草案  激进 功能前卫复杂  mozilla Brande Eich
    // 08   4.0 中止    容易改变   3.1   Harmony  没发布
    // 3.1 -> ECMAScript5
    // 09   5.0 发布   Harmony -> 1/2(不激进) JS.NEXT    1/2(激进)JS.next.next
    // 11   5.1  ISO 国际标准  还是几乎基于3.0的
    // 13   ES6  =js.next   js.next.next   7
    // 13   ES6草案发布
    // 15   ES6正式发布. ESMAScript2015


    // ES5  正常模式  严格模式
    // IE9及以下IE 不支持严格模式
    // 3.0 -> 严格模式  为ES5做铺垫  语法严谨  安全性 效率问题
    // 'use strict';
    // 为什么用字符串
    // 因为字符串不会报错  是表达式  怎么写都不报错
    // 浏览器不支持不至于报错
    // function useStrict(){  3.0buzhichijiuhuibaocuo

    // }  容易报错
    // useStrict();

    // 在脚本的最上面一行去写
    /* 'use strict'; //不要求的情况下不能这么写

    function test() { //绝大部分公司要求这么写 而不是写到全局里面去
      'use strict';

    }

    var test = (function test() {
      'use strict';

    })(); */


    // with 方法
    /*  var a = 1;
    var obj = {
      a: 2
    }

    function test() {
      var a = 3;
      with(test) {
        console.log(a);
      }
    }
    test(); //3 
 */
    /* var a = 1;
    var obj = {
      a: 2
    }

    function test() {
      var a = 3;
      with(obj) {
        console.log(a);
      }
    }
    test(); //2 */



    /* var a = 1;
    var obj = {
      a: 2
    }

    function test() {
      var a = 3;
      with(window) {
        console.log(a);
      }
    }
    test(); //1 */

    // with可以改变作用域 链 填哪个作用域的名称就找哪个作用于里面相应的a

    /* 'use strict';
    var a = 1;
    var obj = {
      a: 2
    }

    function test() {
      var a = 3;
      with(window) {
        console.log(a);
      }
    }
    test(); //Uncaught SyntaxError: Strict mode code may not include a with statement */

    // with 以后用不到
    /* var a = 1;
    var obj = {
      a: 2
    }

    function test() {
      var a = 3;
      var b = 4;
      with() { //不填值报错
        console.log(a);
        console.log(b);
      }
    }
    test(); //1 */



    // 命名空间问题  害怕同一个空间出现同一个名称的变量和函数名  涉及到重写问题

    /*  var a = 1;
     var a = 2;
     console.log(a); //2
     function test() {
       console.log(1);
     }

     function test() {
       console.log(2);
     }
     test(); //2 */

    // 程序写大了不清楚
    // 多人协作 

    // 不借助框架 直接用JS模块化开发怎么写
    // window.onload = function () {
    //   init();
    // }

    // function init() {
    //   initSlider;
    //   initSlideBar;
    // }

    // var initSlider = (function () {
    //   var a = 1;
    //   console.log(a);
    // })();

    // var initSlider = (function () {
    //   var a = 2;
    //   console.log(a);
    // })();
    // 1
    // 2

    // 以前怎么写的
    /* var namespace = {
      header: {
        Jenny: {
          a: 1,
          b: 2
        },
        Ben: {
          a: 3,
          b: 4,
          c: 5
        }
      },
      sideBar: {
        Crystal: {
          a: 5,
          b: 6
        }
      }
    }
    console.log(namespace.header.Ben.a); //但是实际不可能写这么长
    // 用with解决  改变作用域 太消耗性能
    with(namespace.header.Ben) {
      console.log(c);
    } */

    // 现在用webpack写了 完全组件化来写 模块化多人协作处理

    /* 'use strict';

    function test() {
      console.log(arguments.callee); //ES5严格模式不可以用 arguments下面大部分属性不可用  arguments 可以用
    }
    test(); */
    // Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them

    /* function test() {
      console.log(arguments);  没问题
    }
    test(1, 2, 3);

    function test() {
      console.log(arguments.length);
    }
    test(1, 2, 3); */


    /* 'use strict';

    function test1() {
      test2();
    }
    test1();

    function test2() {
      console.log(test2.caller);
    }
    // Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them */

    // 'use strict';
    // a = 1; //Uncaught ReferenceError: a is not defined  严格模式必须声明变量

    // var a = 1;
    /*  a = 1;
     var a; */

    // var a = b = 1; //Uncaught ReferenceError: b is not defined
    // 没有实例化  非严格模式下
    /* function test() {
      var a = b = 1;
    }
    test(); //Uncaught ReferenceError: b is not defined */

    // console.log(this); //Window

    /*   function test() {
        console.log(this);
      }
      test(); //undefined  严格模式下 函数内部的this必须要赋值 否则就是undefined */

    /* function test() {
      console.log(this); //this指向构造函数实例化出来的对象
    }
    var test1 = new test(); //test{}  new test 之后 就赋值了 return this  指向test1了 

    function test() {
      console.log(this);
    }
    test();
    test.call(1); //1 this严格模式 必须通过call赋值
    new test(); //test {} */


    /*   function test() {
        console.log(this);
      }

      test.call(1); //Number {1}
      test.call({}); //{} */

    // 数字对象 非严格 call写的不是对象 是原始值的话 也会给你变成对象 call改变this指向 this指向的是对象 也就是说 非严格模式下 call添加任何东西就给你变成相应的对象形式 填1 给你包装类变成数字对象

    /*  'use strict';

     function test() {
       console.log(this);
     }

     test.call({}); //{} */

    //  函数的参数不能重复
    /*  function test(a, a) {
       console.log(a);

     }
     test(1, 2); //2 */
    // 'use strict';

    /* function test(a, a) {
      console.log(a);

    }
    test(1, 2); //Uncaught SyntaxError: Duplicate parameter name not allowed in this context
 */
    // 对象属性名不允许重复
    /* var obj = {
      a: 1,
      a: 2
    }

    console.log(obj.a); //  2    ES5 严格模式下不报错  但是不允许使用 */


    /*  eval('var a=1;console.log(a)'); //1
     console.log(a); //1 */


    /* 'use strict';
    eval('var a=1;console.log(a)'); //eval 严格模式下是有自己的作用域
    console.log(a); //Uncaught ReferenceError: a is not defined
    // 外面无法访问 */
  </script>
</body>

</html>