<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- <div data-config="{name: }"></div> //通过data-config这个属性取道data-config后面属性，把{name: } 对象字符串 拿出来转化成对象，取到里面的name，设置成什么
  <script type="text/javascript" src="./js/teacher.js"></script> -->
  <script type="text/javascript">
    /* var t1 = new Teacher({ //js里面配置
      name: '张三', //参数名提醒我是干什么的
      sex: '男',
      weight: 145,
      course: 'JavaScript'
    });
    console.log(t1); */
    // 对象  基础的变量类型
    // 有一些公司工具类的叫函数，普通类的叫方法
    /*  var teacher = {
       name: '张三',
       age: 32,
       sex: 'male', //书信之什么都可以，对象里面还可以跟对象
       height: 176,
       weight: 130,
       teach: function () {
         console.log('I am teaching JavaScript'); //在外面叫函数，在对象里面叫方法（一般认为）
       },
       smoke: function () {
         console.log('I am smoking');
       },
       eat: function () {
         console.log('I am having a dinner');
       }
     }

     // 查询
     console.log(teacher.teach); //function (){...}
     // 执行
     teacher.eat(); //I am having a dinner
     // 增加
     teacher.address = '北京';
     teacher.drink = function () {
       console.log('I am drinking beer');
     }
     console.log(teacher);

     teacher.drink(); //I am drinking beer

     // 更改
     teacher.height = 180;
     teacher.teach = function () {
       cosole.log('Iam teaching HTML');
     }
     console.log(teacher.teach);

     // 删除
     delete teacher.address; //删除属性
     delete teacher.teach; //可以删除  方法
     delete teacher.teach(); //没法删除，会打印出来 */

    // 在对象里面改一下函数的功能
    /* var teacher = {
      name: '张三',
      age: 32,
      sex: 'male',
      height: 176,
      weight: 130,
      teach: function () {
        console.log('I am teaching JavaScript');
      },
      smoke: function () {
        teacher.weight--;//有点奇怪，象是从第三人称说自己做了什么
        console.log(teacher.weight);
      },
      eat: function () {
        teacher.weight++;
        console.log(teacher.weight);
      }
    }

    teacher.smoke();
    teacher.smoke();
    teacher.eat(); */

    // this指代的是对象的本身
    /*     var teacher = {
          name: '张三',
          age: 32,
          sex: 'male',
          height: 176,
          weight: 130,
          teach: function () {
            console.log('I am teaching JavaScript');
          },
          smoke: function () {
            this.weight--;
            console.log(this.weight);
          },
          eat: function () {
            this.weight++;
            console.log(this.weight);
          }
        } */


    // 出勤管理
    /* var attendence = {
      students: [],
      total: 6,
      join: function (name) {
        this.students.push(name);
        console.log(this.students);

      },
      leave: function () {
        arr.splice(0,2); //(第几位开始，删除几项)
      }
    } */

    /* var attendence = {
      students: [],
      total: 6,
      join: function (name) {
        this.students.push(name);
        console.log(this.students);

      },
      leave: function (name) {
        var idx = this.students.indexOf(name);
        if (idx !== -1) {
          this.students.splice(idx, 1);
        }
        console.log(this.students);
      }
    }
    attendence.join('张三');
    attendence.join('李四');
    attendence.join('王五'); // ['张三', '李四', '王五']
    attendence.leave('李四'); //['张三', '王五'] */


    // 总数为6的时候打印学生到齐
    /* var attendence = {
      students: [],
      total: 6,
      join: function (name) { //方法内部可以传参数 🔺
        this.students.push(name);
        if (this.students.length === this.total) {
          console.log(name + '到课，学生已到齐');
        } else {
          console.log(name + '到课，学生未到齐');
        }
      },
      leave: function (name) {
        var idx = this.students.indexOf(name);
        if (idx !== -1) {
          this.students.splice(idx, 1);
        }
        console.log(name + '早退')
        console.log(this.students);
      },
      classOver: function () {
        this.students = []; //下课的时候，清除学生
        console.log('已下课');
      }
    }
    attendence.join('张三'); //调用的时候，传入实参🔺
    attendence.join('李四');
    attendence.join('王五');
    attendence.join('赵六');
    attendence.join('吴七'); //吴七到课，学生未到齐
    attendence.join('孙八'); //孙八到课，学生已到齐
    attendence.leave('李四'); //李四早退
    attendence.classOver(); //已下课 */

    // splice实验
    /* var num = 5; //判断该数是否存在数组里面
    var arr = [1, 2, 3, 4];
    arr.splice(1, 1);
    console.log(arr); //[1,3,4] */

    /* var num = 3; //判断该数是否存在数组里面
    var arr = [1, 2, 3, 4];
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] === num) {
        arr.splice(i, 1); //在就删除
      }
    }
    console.log(arr); //[1, 2, 4] */

    // 另一种方法
    /*  var num = 3;
     var arr = [1, 2, 3, 4];

     console.log(arr.indexOf(num)); //返回下标 2   -1 表示不存在*/


    //  构造函数
    // js中创建对象的方式1    直接Object一个字面量  字面量直接创建对象
    /*  var obj = { 
       name: '张三',
       sex: 'male'
     }
     // 这种访问方法叫对象字面量，对象直接量：声明一个变量，将对象赋值给这个变量
     obj.name = '李四'; */

    //  这两者没有谁优势之说
    // 方法2构造函数  new 一个关键字去实例化对象
    // 系统内自带的构造函数
    // Object系统自带，new一个构造函数=新实例化/new 一个对象
    // 对象和构造函数是两码事
    // 对象：是通过实例化构造函数而得出（创建，构造）的一个对象实例
    // 
    /* var obj = new Object(); //对象字面量相等     new Object  new一个对象
    obj.name = '张三';
    obj.sex = '男士';

    console.log(obj);
     */

    /*  //  自定义构造函数  模块化，插件组件化，都要使用  和普通的函数没有区别function（关键字） +函数名
     // 区别：大驼峰  首个单词字母大写  也可以不按照这么写，功能没区别，但最好写    唯一一个和普通函数区分的表面的区别
     function Teacher() { //没执行，this不存在，this是对象本身，没实例化就没有对象
       this.name = '张三'; //构造函数也有this
       this.sex = '男士'; //这些是纯语句  所以是 = ;
       this.smoke = function () {
         console.log('I am smoking');
       }
     }

     // var teacher = new Teacher(); //实例化了之后才有 对象teacher    this
     // console.log(teacher); //new 了 才有this

     var teacher1 = new Teacher();
     var teacher2 = new Teacher();
     teacher1.name = '李四'; //不会影响2，通过构造函数构造出来的多个对象完全互不影响，完全是不同的对象

     console.log(teacher1, teacher2);

     /* var teacher = {
       name: '张三', //对象里面是都是键值对，键名与键值之间用： 键值对之间用 ，
       say: function () {
         console.log(this.name);
       }
     } */

    // teacher1和teacher2是两个声明，放在栈中，new出来的构造函数，放在堆中，声明和对象一一映射
    // Teacher相当于一个对象的抽象，而t1、t2两个变量相当于抽象的实例化，两者并不相等
    // 面向对象编程（OOP）和语言无关，是一种编程思想，扩展出继承、封装、多态等多种思想 */


    /*  function Teacher() {
       this.name = '张三';
       this.sex = '男士';
       this.weight = 130;
       this.smoke = function () {
         this.weight--;
         console.log(this.weight);
       }
       this.eat = function () {
         this.weight++;
         console.log(this.weight);
       }
     }

     var t1 = new Teacher();
     var t2 = new Teacher();

     t1.smoke();
     t1.smoke(); //128
     console.log(t2.weight); //130  构造函数也可以改变自己的属性，互不影响 */

    // new的过程中姓名、性别等就不一样
    /* function Teacher(name, sex, weight, course) { //和普通传参一样
      this.name = name;
      this.sex = sex;
      this.weight = weight;
      this.course = course;
      this.smoke = function () {
        this.weight--;
        console.log(this.weight);
      }
      this.eat = function () {
        this.weight++;
        console.log(this.weight);
      }
    }

    var t1 = new Teacher('张三', '男', 145, 'JavaScript');
    var t2 = new Teacher('李四', '女', 90, 'HTML');


    console.log(t1);
    console.log(t2); */

    // 传参的改进
    /*  var opt = {
       name: ddd,
       sex: ddgg
     } */

    /*  function Teacher(opt) { //选项、设置项  想象成对象  封装插件的时候就这么写  要拿出去配置都这么写 才好维护   用插件的人才好用   插件有配置项的都这么做
       this.name = opt.name;
       this.sex = opt.sex;
       this.weight = opt.weight;
       this.course = opt.course;
       this.smoke = function () {
         this.weight--;
         console.log(this.weight);
       }
       this.eat = function () {
         this.weight++;
         console.log(this.weight);
       }
     }

     var t1 = new Teacher({
       name: '张三',
       sex: '男',
       weight: 145,
       course: 'JavaScript'
     });
     var t2 = new Teacher({
       name: '李四',
       sex: '女',
       weight: 90,
       course: 'HTML'
     });

     console.log(t1);
     console.log(t2); */

    // 写一个构造函数，接收数字类型的参数，参数数量不定，完成参数相加和相乘的功能
    /* function Compute() {
      var args = arguments,
        res; //保存实参集合  因为下面的函数没有传参 用不到arguments
      this.plus = function () {
        var res = 0;

        for (var i = 0; i < args.length; i++) {
          var item = args[i]; //保存一下
          res += item;
        }
        console.log(res);
      }

      this.times = function () {
        res = 1;
        for (var i = 0; i < args.length; i++) {
          var item = args[i];
          res *= item;
        }
        console.log(res);
      }
    }

    var compute = new Compute(2, 4, 6);
    compute.plus(); //14
    compute.times(); //48 */

    // 有些部分过于重复 改进
    /* function Compute() {
      var args = arguments,
        res;
      this.plus = function () {
        var res = 0;
        loop('add', res)
      }
      this.times = function () {
        res = 1;
        loop('mul', res);
      }

      function loop(method, res) {
        for (var i = 0; i < args.length; i++) {
          var item = args[i];
          if (method === 'add') {
            res += item;
          } else if (method === 'mul') {
            res *= item;
          }
        }
        console.log(res);
      }
    }

    var compute = new Compute(2, 4, 6);
    compute.plus();
    compute.times(); */

    // 这个方法更好
    /* function Compute() {
      var res = 0;
      this.plus = function () {
        loop(arguments, 'add', res);
      }
      this.times = function () {
        res = 1;
        loop(arguments, 'mul', res);
      }

      function loop(args, method, res) {
        for (var i = 0; i < args.length; i++) {
          var item = args[i];
          if (method === 'add') {
            res += item;
          } else if (method === 'mul') {
            res *= item;
          }
        }
        console.log(res);
      }
    }
    var compute = new Compute();
    compute.plus(2, 4, 6); //12
    compute.times(3, 5, 7); //105 */



    // 写一个构造车的函数，可设置车的品牌，颜色，排量
    // 再写一个构造消费者的函数，设置用户的名字，年龄，收入，通过选择的方法实例化该用户喜欢的车，在设置车的属性

    /* function Car(opt) {
      this.brand = opt.brand;
      this.color = opt.color;
      this.displacement = opt.displacement;
    }

    function Person(opt) {
      this.name = opt.name;
      this.age = opt.age;
      this.income = opt.income;
      this.selectCar = function () {
        var myCar = new Car(opt.carOpt); //实例化的时候才传参  对应的是一个对象
        console.log(this.name + '挑选了一辆排量为' + myCar.displacement + '的' + myCar.color + myCar.brand);
      }
    }

    var jone = new Person({
      name: '约翰',
      age: 29,
      income: '20K',
      carOpt: {
        brand: '马自达',
        color: '红色',
        displacement: '2.0'
      }
    })
    jone.selectCar(); //约翰挑选了一辆排量为2.0的红色马自达 */
  </script>
</body>

</html>