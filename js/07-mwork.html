<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

  <!-- <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
  </ul> -->
  <script type="text/javascript">
    /*   // 经典面试题
    var oLi = document.querySelectorAll('li'); //也是闭包问题

    for (var i = 0; i < oLi.length; i++) {
      oLi[i].onclick = function () { //onclick也是相当于抛出去了
        console.log(i); //5   鼠标点击哪个都是5
      }
    } */


    // 解决方案
    /*   var oLi = document.querySelectorAll('li');

      for (var i = 0; i < oLi.length; i++) {
        (function (j) {
          oLi[j].onclick = function () {
            console.log(j);
          }
        })(i);
      } */

    /*   function test1() {
      console.log(1);
    }

    function test2() {
      console.log(2);
    }

    test(2);

    function test3() {
      test1();
    }
    test3(); //   21     写到全局的函数其实都是保存在GO里面的，不释放，在哪里想调用都可以直接用，无需再定义

    // 页面加载完毕的时候接受两个参数，从后台传过来，每次加载页面的时候就要求得两个参数的和。每一次加载页面的时候，程序只用一次

    add(1, 2);

    function add(a, b) {
      console.log(a + b);
    } //只执行一次，后面就放在GO里面了，满足需求不强


    cons.log(add(1, 2));
    // 不释放,也不自己执行
    function add(a, b) {
      return a + b;
    } */





    // 自动执行，执行完成以后立即释放
    // 立即执行函数 - 初始化函数    解决不释放,也不自己执行
    // IIFE immediately-invoked function expression
    // 立即执行函数写法
    /*  (function(){

     })();

     (function(){

     }());  //W3C建议    后面要加分号   因为是表达式  类似于(1+2)*3  1;  (1);  */
    // 把函数声明括起来就是一个表达式了   括号把任何东西((函数声明\数字...)括起来都是一个表达式也能转换为表达式


    // 函数表达式
    /* var test = function () {}
      (function test() {})

    (function test() {

    })();

    等于

    function test() {

    }
    test();

 */

    /*  function test() {}(); //不能执行

      (function test1() {
        consol.log(1); //可以
      })();

      var test = function () {
        console.log(1); //1
      }(); //可以执行

      function test3() {
        console.log(1);
      }(); //不可以执行

      // 一定是表达式才能被执行符号执行



      var test = function () {
        console.log(1);
      }

      consoel.log(test);
      //function () {
      // console.log(1);
      // }

      var test1 = function () {
        console.log(1); //1
      }();

      console.log(test1); //undefined */



    /* 
        (function () {
          console.log(123); //函数声明变成表达式就会忽略其函数名,因为立即销毁,也无需拿到函数名才能执行,所以函数名没用
        })

        (function test() {
          console.log(123); //立即执行函数必须是一个表达式才能被立即执行
        })

        var num = (function () {
          return 123;
        })();

        console.log(num);

        (function () {
          var a = 1,
            b = 2;
          console.log(a + b); //3 
        }()); //目的是为了得到值是多少

        (function test() {
          var a = 1,
            b = 2;
          console.log(a + b); //3
        }()); //目的是为了得到值是多少
        // 找不到test.执行完之后就销毁了

        (function test(a, b) { //形参再function里面的括号里写
          console.log(a + b); //3
        }(1, 2)); //实参在函数执行括号里面写

        // 类比于   小括号是执行符号,可在里面传参数
        function test() {

        }
        test();


        立即自己执行
        执行完之后完全被释放
        拿到返回的值(但是因为立即释放, 有另一种写法)


        拿到返回值的写法: 把该函数交给一个变量来保存
        var num = (function test(a, b) {
          return a + b;
        }(1, 2));
        consol.log(num);


        (function () {
          var a = 1,
            b = 2;
          return a + b; //也可以return
        }()); //目的是为了得到值是多少
     */

    // 函数声明变成表达式的其它方法  +   -  ||  &&  ||  &&前面要加一个东西才行(要保证该表达式为真才能执行)
    /* 0 && function test() {
      console.log(1); //不能
    }();

    1 && function test() {
      console.log(1); //能
    }();

    console.log(test); //报错,已忽略函数名,引用错误

    // 将函数声明变为表达式之后,就可以使用执行符号,立即执行该函数,并且函数名自动被忽略带哦 */


    // 面试题
    /* function test(a) {

    }(6); //不报错   把(6);当成一个表达式了    ();就会报错
    //这里各位不要这样考虑，会显得js非常混乱，实际上（6）这一块，和前面函数声明毛关系没有，分开写后，注释掉函数声明部分也不会报错
    // 原因是（6）只会被解析为一个字面量为6的表达式，而前面的函数声明在预编译时就被提升上去了
    // 否则这绝不是解释器优化，而是js一个明显的设计错误
    // 完全错误，和优先级没有关系，而是表达式的处理和声明的处理在解释器中不是同一时间处理的
    // 函数声明在预编译时就处理完毕了，但是表达式在解释执行时才会处理

    console.log(6, 5); //逗号其实是一个比较/逻辑运算,只返回逗号后面最后的值
 */

    /*     //  逗号运算
        var num = (2 - 1, 6 + 5, 24 + 1);
        console.log(num);

        function test(a) {

        }(6);
     */
    /*  //等于
     var num = (6);
     console.log(num); */


    // 笔试经典案例
    /*  function test() {
       var arr = [];

       for (var i = 0; i < 10; i++) {
         arr[i] = function () {
           document.write(i + ' ');
         }
       }
       return arr;
     }

     var myArr = test();
     console.log(myArr); //{f,f,f,f,f,f,f,f,f,f}   只是保存函数,但是没有执行


     for (var j = 0; j < 10; j++) { //因为是数组,所以要用循环执行一遍
       myArr[j](); // 10个10   取得i值时已经是10,同时执行函数,打印出来
     } */



    // 10个10的解释
    /*   function test() {
        var arr = [];
        var i = 0; //把一些东西拿出来就看得懂了
        for (; i < 10;) {
          arr[i] = function () { //匿名函数没有立即执行
            document.write(i + ' '); //不看这了
          }
          i++;
        }
        return arr;
      } */
    // return arr时i已经是循环到10了,而且被arr里面的每一个函数拽住,执行结束时test()和它的AO断线,但是它的AO没有销毁,被10个匿名函数拿着,它的AO有一个变量i,return arr时i已经是循环到10了,再怎么打印都是10,面试的时候要和AO一起说,或者画图也可以





    // 问题根源在于循环中var 声明的变量提升，它会存在于test函数的上下文，但又因为闭包后，test上下文不会被回收

    // 因此最下面循环时，上面循环索引值i已经变成了10，所以下面执行数组中的匿名函数时，指向的就是已经变成10的i


    // 还不明白看这
    /*   function test() {
        n = 10;
        var a = function () {
          console.log(n);
        }
        var b = function () {
          console.log(n);
        }
        return [a, b];
      }

      var arr = test(); */


    // 想要打印0~9
    /* function test() {

      for (var i = 0; i < 10; i++) {
        (function () {
          document.write(i + ' ');
        }());
      }
    }

    test(); //0 1 2 3 4 5 6 7 8 9

    function test() {

      for (var i = 0; i < 10; i++) {
        (function () {
          document.write((i + 1) + ' '); //循环立即执行,每一次拿到的i就不一样了
        }());
      }
    }
    test(); //1 2 3 4 5 6 7 8 9 10 */

    // 原来的写法也可以这么做
    /*  function test() {
       var arr = [];

       for (var i = 0; i < 10; i++) {
         arr[i] = function (num) {
           document.write(num + ' ');
         }
       }
       return arr;
     }
     var myArr = test();
     for (var j = 0; j < 10; j++) {
       myArr[j](j);
     }

     function test() {
       var arr = [];

       for (var i = 0; i < 10; i++) {
         arr[i] = function (num) {
           document.write((num + 1) + ' ');
         }
       }
       return arr;
     }
     var
       myArr = test();
     for (var j = 0; j < 10; j++) {
       myArr[j](j);
     }


     // 还有另一种写法(最常用的)   let就解决的了
     function test() {
       var arr = [];

       for (var i = 0; i < 10; i++) {
         (function (j) { //循环的是立即执行函数
           arr[j] = function () {
             document.write(j + ' '); //把i值保存到立即执行函数里面
           }
         })(i);

       }
       return arr;
     }
     var
       myArr = test();
     for (var j = 0; j < 10; j++) {
       myArr[j]();
     } //这才是不改变var之外的正确解法，前面的解法都是在改需求了，属于耍流氓

     // 主要是这时候可能没讲函数的回调，函数表达式的执行实际并不是在循环执行时，而是执行之后，那时i已经是5了 */

    /*  (1, 2); //逗号运算符,只打印后面一个
     var fn = (
       function test1() {
         return 1;
       }, //逗号运算符
       function test2() {
         return '2';
       }
     )();

     console.log(typeof (fn));

     var num = (1, 2);
     console.log(num); */


    /* var a = 10;
    if (function b() {}) { //不是false,是函数
      a += typeof (b); //括号括起来,变成表达式,忽略了函数名,在这一步已经不存在,变成undefined,答应出来会报错,只有typeof不报错
    }

    console.log(a); */

    /*  累加器 0;闭包, 初始数据是零, 每执行一次加1

     缓存器, 一个班级学生名字保存在数组里, 两个方法写在函数中的一个对象中, 第一个方法加入班级, 第二个方法离开班级, 每次加入或者离开都需要重新打印新的学生名单 */


    /* function test() {
      var num = 0;

      function add() {
        console.log(++num);
      }
      return add;
    }

    var add = test();
    add();
    add();
    add();
    add();
    add();
    add(); */

    /* function myClass() {
      var students = [];

      var operation = {
        join: function (name) {
          students.push(name);
          console.log(students);
        },
        leave: function (name) {
          for (var i = 0; i < students.length; i++) {
            var item = students[i]; //做一个数据缓存，优化for循环性能 
            if (item === name) {
              students.splice(i, 1);
            }
          }
          console.log(students);
        }
      }
      return operation;
    }
    var obj = myClass();
    obj.join('张三');
    obj.join('李四');
    obj.join('王五');
    obj.leave('李四'); //['张三', '王五' ] */



    /* function myClass() {
      var students = [];
      var
        operation = {
          join: function (name) {
            students.push(name);
            console.log(students);
          },
          leave: function (name) {
            var
              idx = students.indexOf(name);
            if (idx !== -1) {
              students.splice(idx, 1);
            }
            console.log(students);
          }
        }
      return
      operation;
    }
    var obj = myClass();
    obj.join('张三');
    obj.join('李四');
    obj.join('王五');
    obj.leave('李四'); //['张三', '王五' ] */
  </script>
</body>

</html>