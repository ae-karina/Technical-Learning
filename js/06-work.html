<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script type="text/javascript">
    // AO GO作用域
    // 作用域链相关所产生的一切问题
    //AO -> function 独立的仓库


    // 对象
    /*    var obj = {
         name: '蓝轨迹', //属性 键名后面跟了字符串或数据类型
         address: '北京',
         teach: function () { //方法  键名后面跟了一个函数

         }
       }
       console.log(obj.name) //对象有自己的属性和方法 */

    // 函数也算是一个对象类型    引用类型   引用值
    // test.name test.length test.protoytpe 
    //对象 ->有些属性是我们无法访问的
    //       JS引擎内部固有的隐式属性

    // [[scope]]
    // 1.函数创建时，生成的一个JS内部的隐式属性  只能由JS的引擎读取
    // 2.函数存储作用域链的容器，作用域链 ：  保存AO/GO的容器
    // 作用域链其实就是 AO/GO
    // AO，函数的执行期上下文
    // GO，全局的执行期上下文
    // 函数执行完成以后，AO是要销毁的，
    // AO是一个及时的存储容器，执行新函数的时候产生新的，执行完成之后销毁
    // scope就是 把AO/GO形成链式从上到下排列，形成链式的关系

    /* function test(a, b) {

    }
    console.log(test, length); //2 */

    /*  function a() {
       function b() {
         var b = 2;
       }
       var a = 1;
       b();
     }
     var c = 3;
     a(); */
    // 函数定义的时候就把GO保存好了   GO永远有一个函数连着
    // 一个函数由AO、GO
    // 外函数执行，内函数被定义
    // GO是同一个，函数存的是GO的地址  GO不会看函数里面的内容

    // 全局在执行的前一刻GO  -> 函数声明已经定义
    // 全局执行，内函数定义
    // 函数被定义的时候已经形成作用域链，还有GO，执行的时候才生成自己的AO
    // [[scope]] -> scope chain -> GO -> AO



    /* test2();

    function test2() {

    }

    test();
    var test = function () {

    }

    执行过程： */
    // GO={
    //   test:undefined- >       执行时函数根本不存在 
    //        function () {}     全局执行的时候才被赋值
    //   test2:function test2(){...}   定义函数
    // }






    // 为什么定义的时候要生成GO，因为所有函数都必须有一个GO
    // 定义的时候拿的是上级的环境
    // 函数执行结束之前，再执行一次（刷新）就会再生成一个AO环境  AO的拿的也是地址 
    // 为什么外面无法访问里面的变量
    // 因为外的函教没有内部函数的AOF境但是内部函教在执行的时候因为引用了外部函数的A0上下文 所以 就同时存在多个A0所以晓访间

    /* function a() {
      function b() {
        var b = 2;
      }
      var a = 1;
      b();

      console.log(b);
    }
    var c = 3;
    a();

    /*   function b() {
      var b = 2;
      } */


    /*    function a() {
         function b() {
           var b = 2;
         }
         var a = 1;
         b();

         console.log(b);
       }
       var c = 3;  */
    //  a();
    // A函数不执行的时候怎么处理，GO只存function a(){...}

















    /*   function a() {
      function b() {
        function c() {

        }
        c();
      }
      b();
    }
    a();
 */
    //a定义: a.[[scope]]G0
    //a执行: a.[[scope]]a->A0
    //b定义:b.[[scope]] ->a->A0
    //b执行:b.[[scope]] ->b-> A0








    // 闭包
    /* function test1() {
      function test2() {
        var b = 2;
        console.log(a);
      }
      var a = 1;
      return test2();
    }
    var c = 3;
    var test3 = test1();
    test3();
 */

    // 当内部函数被返回到外部并保存时，一定会产生闭包，闭包会产生原来的作用域链不释放，过渡的闭包可能会导致内存泄漏，或加载过慢。

    /*    function test() {
         var n = 100;

         function add() {
           n++;
           console.log(n);
         }

         function reduce() {
           n--;
           console.log(n);
         }
         return [add, reduce];
       }
       var arr = test();
       arr[0]();
       arr[1]();
       arr[1]();
       arr[1]();
       arr[1]();
       arr[1]();
       arr[1](); */

    // 也算一种数据缓存


    /*  function breadMgr(num) {
       var breadNum = arguments[0] || 1;

       function supply() {
         breadNum += 10;
         console.log(breadNum);
       }

       function sale() {
         breadNum--; //两个函数平级，没有它们之间互相的AO
         console.log(breadNum);
       }
       return [supply, sale];
     }

     var breadMgr = breadMgr(20);
     breadMgr[0]();
     breadMgr[1]();
     breadMgr[1]();
     breadMgr[1]();
     breadMgr[1](); */




    // function sunSched() {
    //   var sunSched = '';

    //   var operation = {
    //     setSched: function (thing) {
    //       sunsched = thing;
    //     },
    //     showSched: function () {
    //       console.log("My schedule on sunday is " + sunsched);
    //     }
    //   }
    //   return operation;
    // }

    // var sunSched = sunSched();

    // sunSched.setSched('studying');
    // sunSched.setSched('walking');
    // sunSched.showSched();



    function sunSched() {
      var sunSched = '';


      function setSched(thing) {
        sunsched = thing;
      }

      function showSched() {
        console.log("My schedule on sunday is " + sunsched);
      }

      return [setSched, showSched];
    }

    var sunSched = sunSched();
    sunSched[0]('studying');
    sunSched[1]();
  </script>
</body>

</html>