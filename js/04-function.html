<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script type="text/javascript">
    // x,y 任意X  确定的Y   X自变量   y ->x函数
    // y =f(x)   函数值就是确定的   有确定性

    // 函数式编程

    /*  function test(a,b,c){
       // 执行语句
     } */

    // if (3 > 0) {
    //   test();
    // }
    // if (2 > 0) {
    //   test();
    // }
    // if (1 > 0) {
    //   test();
    // }

    // function test() {
    //   for (var i = 0; i < 10; i++) {
    //     console.log(i);
    //   }
    // }

    // 耦合  代码重复度太高 
    // 高内聚，低耦合   -> 模块的单一责任制
    // 解耦合   js最好的办法就是函数   只有被调用才执行
    // function test() {
    //   console.log('我是很牛的函数');
    // }

    // 函数名的命名规则
    // 不能数字开头
    // 字母_$
    // 包含数字
    // 小驼峰命名法  符合单词 myWonderfulTest   一般的用这个就可以了
    // my_Wonderful_Test   工具类函数用下划线
    // 最基本的函数写法  - 函数声明
    // function test(参数){
    //   // 函数的执行语句
    // }

    // 函数声明
    // function test() {
    //   // var a = 1,
    //   //   b = 2;

    //   // var a = b = 1;  不要这么写
    //   // var b=1;局部变量
    //   // b=1; 全局变量  window上
    //   console.log(a, b);
    // }

    // 匿名函数表达式  函数字面量
    // var test = function {匿名函数
    //   var a = 1,
    //     b = 2;
    //   console.log(a, b);
    //   // test1();递归
    // }
    // 字面量： 函数、 数组...
    // console.log(test.name);
    // test();
    // test1();
    // 给表达式赋的值是function的时候，会自动忽略function的命名，可以写或者不写，但是也会有自己的用处，只有内部可调用，外部不可见

    // function 函数名 参数(可选) 返回值() return  函数是自动添加return
    // var aa = Number(window.prompt('a'));
    // var bb = Number(window.prompt('b'));
    // 定义参数，在调用的时候才赋值，占位  ->形式上占位，形式参数
    // function test(a, b) {

    //   // 实参和形参调用时位置要一一对应
    //   console.log(a - b);
    // }
    // //       实际参数  实参
    // test(false, null);
    // function test(a, b) {
    // console.log(arguments); arg是参数的意思，可以查看自己使用了哪些参数
    // console.log(arguments[1]); 取到实参的哪一位

    // console.log(test.length);  测形参的个数
    // console.log(arguments.length);
    // for (var i = 0; i < arguments.length; i++) {
    //   console.log(arguments[i]);
    // }
    // console.log(a, b, c);
    // }
    // test(1, 2, 3);
    // 形参和实参数量可不等


    // 一个函数被调用时，累加他的实参值
    // function sum() {
    //   var a = 0;
    //   for (var i = 0; i < arguments.length; i++) {
    //     a += arguments[i];
    //   }

    //   console.log(a);
    // }

    // sum(1, 2, 3, 4, 5, 6, 10);

    // function test(a, b) {
    //   a = 3;   实参有值的话，函数内部可以改变实参的值   这个和实参不是同一个东西  形参没有实参的值，则不存在映射关系
    //   console.log(arguments[0]);
    // }
    // test(1, 2);

    // function test(a, b) {
    //   b = 3;  实参没有值，则函数内部赋值也没用  undefined          
    //   console.log(arguments[1]);
    // }
    // test(1, 2);

    // function test() {
    //   console.log('我正在执行');
    //   console.log('我执行完了就结束这个函数');
    //   // return;  默认添加return，隐式添加，中止函数的执行。retur下面的所有语句都不会执行
    // }
    // test();

    // function test(name) {
    //   if (!name) {
    //     return '您没有填写姓名！'; //还可以返回相应值，同时也执行了中止函数的过程
    //   }
    //   return name; //console.log的话下面语句也会打印出来
    // }

    // console.log(test('艾小野'));
    // function test(name) {
    //   return name || '您没有填写姓名！'; //后面的是真
    // }
    // // undefined null NaN " " 0 false
    // console.log(test('艾小野'));

    /* a = 1; //全局变量

    function test1() {
      // 局部变量
      var b = 2;
      // console.log(a, b);
      a = 4;

      function test2() { //内部的变量可以访问外部的变量，但是外部不能访问内部
        // 局部变量
        var c = 3;
        b = 5;
        console.log(b);
        // console.log(a, b, c);   内部的越是刻意打到外部的
      }
      test2();
      // console.log(c);
    }
    test1(); */
    // console.log(a);
    // console.log(a); //不能打印出来，因为是局部变量，变量没有定义，会直接报引用错误   ocnsole.log(typeof(a)) undefined


    // function test1() {
    //   var a = 1;
    //   console.log(b);
    // }

    // function test2() {
    //   var b = 2;
    //   console.log(a);
    // }

    // teat1();
    // test2();

    // 一个固定的功能或是者程序段被封装的过程， 实现一个固定的功能或者是程序， 在这个封装体中需要一个入口和一个出口， 入口就是参数， 出口就是返回

    // function test(str1, str2, str3) { //相当于一个盒子把函数封装起来
    //   console.log(str1);
    //   console.log(str2);
    //   console.log(str3)
    // }
    // test(
    //   '我爱编程',
    //   '我特爱编程',
    //   '我是编程达人'
    // );
    // function test(str1, str2, str3) { //相当于一个盒子把函数封装起来
    //   return str;
    // }
    // console.log(test('我爱编程'));

    // 1.定义一个函数，从wp接收一个饮料的名称函数返回对应的价格
    // 2.定义一个函数，从wp接收第一个数，接收个运算符号 (+ - */%) ，接收第二个数，利用这个函数做运算，并返回运算结果
    // 3.定义一个函数，从WP接收一个n，算出n的阶乘，不能用for循环
    // 4.定义一个函数，从WP接收一个n,算出斐波那契数列的第N位，不能用for循环
  </script>
</body>

</html>